border b(t=0,2*pi){x=cos(t); y=sin(t); label = 1;};
mesh Th = buildmesh(b(10));

// mesh Th = square(80,80,[-30 + 60 * x, -30 + 60 * y],flags = 1);

plot(Th);

func g = 0.5 * (x^3 - 3 * x * y);

func real Phi(real & x, real & y, real x0, real y0){
if(x == x0 && y == y0)
	return 0;
return 1 / (2 * pi) * log(1 / ((x - x0)^2 + (y - y0)^2)^0.5);
}

fespace Vh(Th, P1);

/*
//func d = (x-2)^2 + (y)^2 - 16 <= 0;
func d = (abs(x) - 3 <= 0) * ((abs(y) - 10 <= 0));

func gamma = 1 + 1 * d;

fespace Vh(Th, P1);
Vh uh, vh;
Vh fh = f;
problem lap(uh, vh) = 
	int2d(Th)(gamma * (dx(uh) * dx(vh) + dy (uh) * dy(vh)))
	+int2d(Th)((gamma - 1) * (dx(fh) * dx(vh) + dy(fh) * dy(vh)))
	+on(1,2,3,4, uh = 0);
lap;

//*/


///*
////////
Vh xh = x, yh = y;
//////// compute indnod
include "indnod.edp"
real nboundary = getnboundary();
int[int] indnod(nboundary); getindnod(indnod, nboundary);
////////
real[int] gh(nboundary);
// cout << "nboundary = " << nboundary << endl;
// cout << "ndof = " << Vh.ndof << endl;
// cout << indnod << endl;
for(int k=0; k<nboundary; k++){
	gh[k] = g(xh[][indnod[k]], yh[][indnod[k]]);
}

// real[int] rhs = [1, g0];

Vh phih = 0;
func real int1dBasis(int ind){
	phih[] = 0;
	phih[][ind] = 1;
	return int1d(Th,1)(phih);
}
real[int] temp1d(nboundary);
for(int k=0; k<nboundary; k++){
temp1d[k] = int1dBasis(indnod[k]);
}

func real int1dEBasis(real & xix, real & xiy, int ind){
	phih[] = 0;
	phih[][ind] = 1;
	return int1d(Th,1)(phih * Phi(x,y,xix,xiy));
}
real xx = 0, yy = 0;
//cout << int1dEBasis(xx,yy,1) << endl;
///*
real[int,int] M(nboundary,nboundary);
// M.resize(nboundary, nboundary);
for(int i = 0; i<nboundary; i++){
for(int j = 0; j<nboundary; j++){
M(i,j)=int1dEBasis(xh[][indnod[i]], yh[][indnod[i]], indnod[j]);
}
}
cout << M << endl;
/*
real[int] ones(nboundary); ones=1;
real a11 = 1e-16;

matrix A = [[a11, temp1d'],[ones, M]];
//real[int,int] A = [[a11, temp1d'],[ones, M]];
// A(1,1) = 12;

set(A, solver=GMRES);
real[int] sol(nboundary + 1); // WARNING: construct immediately with right size

/*cout << A << endl;
cout << A(0,0) << endl;
cout << temp1d << endl;
cout << rhs << endl;
*/

/*
sol = A^-1*rhs;

Vh extsol = 0;
for(int k = 0; k < nboundary; k++){
extsol[][indnod[k]] = sol[k+1];
}
/////////////////////////////////////
func real intVolumeSolution(real & xix, real & xiy){
	return int2d(Th)(extsol * E(x,y,xix,xiy));
}

Vh w0;

for(int k=0; k < Vh.ndof; k++)
	w0[][k] = sol[0] + intVolumeSolution(xh[][k], yh[][k])
	+ intVolumePotential(xh[][k], yh[][k]);;
plot(Th, w0, fill=1, value=1);
//*/


Vh w0ex = g;
plot(Th, w0ex, fill=1, value=1);


 
phih[] = 0;
phih[][indnod[0]] = 1;
Vh hh = (phih * Phi(x,y,xh[][indnod[0]],yh[][indnod[0]]));
plot(Th, hh, fill=1);